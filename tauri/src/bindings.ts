
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async isLoggedIn() : Promise<Result<boolean, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_logged_in") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async login() : Promise<Result<null, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("login") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async favouriteAlbums() : Promise<Result<FavouriteAlbumDTO[], ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("favourite_albums") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async albumTracks(id: string) : Promise<Result<TrackDTO[], ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("album_tracks", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async userPlaylists() : Promise<Result<PlaylistDTO[], ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("user_playlists") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async playlistTracks(id: string) : Promise<Result<TrackDTO[], ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("playlist_tracks", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async queueTrack(id: string) : Promise<Result<null, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("queue_track", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async queueAlbum(id: string) : Promise<Result<null, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("queue_album", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async play() : Promise<Result<null, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("play") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async pause() : Promise<Result<null, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pause") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async skip() : Promise<Result<null, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("skip") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async previous() : Promise<Result<null, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("previous") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async devices() : Promise<Result<CommandDeviceDTO[], ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setDevice(device: string) : Promise<Result<null, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_device", { device }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async lyrics(id: string) : Promise<Result<string | null, ErrorDTO>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("lyrics", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
loggedIn: LoggedIn,
queueUpdated: QueueUpdated,
updatedCurrentTrack: UpdatedCurrentTrack,
updatedPauseState: UpdatedPauseState,
updatedTrackProgress: UpdatedTrackProgress
}>({
loggedIn: "logged-in",
queueUpdated: "queue-updated",
updatedCurrentTrack: "updated-current-track",
updatedPauseState: "updated-pause-state",
updatedTrackProgress: "updated-track-progress"
})

/** user-defined constants **/



/** user-defined types **/

export type AlbumDTO = { 
/**
 * Unique album identifier
 */
id: string; 
/**
 * List of artists who contributed to this album
 */
artists?: ArtistSummaryDTO[]; 
/**
 * Audio quality level available for this album for standard streaming
 * 
 * Higher quality streams may be available than is indicated here when using MPEG-DASH for playback.
 */
audioQuality: AudioQualityDTO; 
/**
 * Total duration of the album in seconds
 */
duration: number; 
/**
 * Whether the album contains explicit content
 */
explicit: boolean; 
/**
 * Album title
 */
title: string; 
/**
 * Popularity score for the album
 */
popularity: number; 
/**
 * Additional media metadata and tags
 */
mediaMetadata: MediaMetadataDTO | null; 
/**
 * Album cover image identifier
 * 
 * Use cover_url() to get the full URL of the cover image.
 */
cover: string | null; 
/**
 * Video cover identifier (if available)
 */
videoCover: string | null; 
/**
 * Dominant color extracted from the cover art
 */
vibrantColor: string | null; 
/**
 * Original release date of the album
 */
releaseDate: string | null; 
/**
 * Date when the album became available for streaming
 */
streamStartDate: string | null; 
/**
 * Copyright information
 */
copyright: string | null; 
/**
 * Total number of tracks on the album
 */
numberOfTracks: number; 
/**
 * Number of videos included with the album
 */
numberOfVideos: number; 
/**
 * Number of volumes (for multi-disc albums)
 */
numberOfVolumes: number; 
/**
 * Universal Product Code (UPC) for the album
 */
upc: string | null; 
/**
 * Tidal URL for the album
 */
url: string; 
/**
 * Album version or edition
 */
version: string | null; 
/**
 * Type of album (ALBUM, EP, Single, etc.)
 */
type: AlbumTypeDTO; 
/**
 * Whether the album is ready for ad-supported streaming
 */
adSupportedStreamReady: boolean; 
/**
 * Whether streaming is allowed for this album
 */
allowStreaming: boolean; 
/**
 * Whether the album is ready for DJ use
 */
djReady: boolean; 
/**
 * Whether the album requires payment to stream
 */
payToStream: boolean; 
/**
 * Whether the album is only available to premium subscribers
 */
premiumStreamingOnly: boolean; 
/**
 * Whether the album supports stem separation
 */
stemReady: boolean; 
/**
 * Whether the album is ready for streaming
 */
streamReady: boolean; 
/**
 * Available audio modes for this album
 */
audioModes: string[] }
/**
 * A simplified representation of an album used in track listings.
 * 
 * This structure contains only the basic album information
 * and is commonly used in track metadata and search results.
 */
export type AlbumSummaryDTO = { 
/**
 * Unique album identifier
 */
id: string; 
/**
 * Album title
 */
title: string; 
/**
 * Album cover image identifier
 */
cover: string | null; 
/**
 * Album release date
 */
releaseDate: string | null; 
/**
 * Dominant color extracted from the cover art
 */
vibrantColor: string | null; 
/**
 * Video cover identifier (if available)
 */
videoCover: string | null }
export type AlbumTypeDTO = 
/**
 * Standard album release
 */
"ALBUM" | 
/**
 * Long play album
 */
"LP" | 
/**
 * Extended play album
 */
"EP" | 
/**
 * Single track release
 */
"SINGLE" | 
/**
 * Collection of EPs and singles
 */
"EPSANDSINGLES" | 
/**
 * Compilation album
 */
"COMPILATIONS"
export type ArtistSummaryDTO = { 
/**
 * Unique artist identifier
 */
id: string; 
/**
 * Artist name
 */
name: string; 
/**
 * Artist profile picture identifier
 * 
 * Use picture_url() to get the full URL of the picture
 */
picture: string | null; 
/**
 * Whether the artist has cover art available
 */
containsCover?: boolean; 
/**
 * Popularity score for the artist
 */
popularity?: number | null; 
/**
 * Type/category of the artist
 */
type?: string | null }
export type AudioQualityDTO = 
/**
 * Low quality (typically 96 kbps AAC)
 */
"LOW" | 
/**
 * High quality (typically 320 kbps AAC)
 */
"HIGH" | 
/**
 * Lossless quality (FLAC, typically 44.1 kHz / 16-bit)
 */
"LOSSLESS" | 
/**
 * Hi-Res Lossless quality (FLAC, up to 192 kHz / 24-bit)
 */
"HI_RES_LOSSLESS"
export type CommandDeviceDTO = { name: string; id: string }
export type ErrorDTO = { error: string }
export type FavouriteAlbumDTO = { created: string; item: AlbumDTO }
export type LoggedIn = null
export type MediaMetadataDTO = { 
/**
 * Tags associated with the media
 */
tags?: string[] }
/**
 * Information about the creator of a playlist.
 * 
 * This structure contains details about who created the playlist,
 * which can be a user or system-generated content.
 */
export type PlaylistCreatorDTO = { 
/**
 * The user ID of the playlist creator.
 * Will be None or zero if the playlist creator is not a known user.
 */
id?: string | null }
/**
 * Represents a playlist from the Tidal catalog.
 * 
 * This structure contains all available information about a playlist,
 * including metadata, statistics, and modification capabilities.
 */
export type PlaylistDTO = { 
/**
 * Unique playlist identifier (UUID format)
 */
uuid: string; 
/**
 * Playlist title
 */
title: string; 
/**
 * Tidal URL for the playlist
 */
url?: string | null; 
/**
 * Information about the playlist creator
 */
creator: PlaylistCreatorDTO; 
/**
 * Playlist description
 */
description?: string; 
/**
 * Total number of tracks in the playlist
 */
numberOfTracks: number; 
/**
 * Total number of videos in the playlist
 */
numberOfVideos: number; 
/**
 * Total duration of the playlist in seconds
 */
duration: number; 
/**
 * Popularity score for the playlist
 */
popularity: number; 
/**
 * ISO timestamp when the playlist was last updated
 */
lastUpdated: string; 
/**
 * ISO timestamp when the playlist was created
 */
created: string; 
/**
 * ISO timestamp when the last item was added to the playlist
 */
lastItemAddedAt: string | null; 
/**
 * Type of playlist (e.g., "USER", "EDITORIAL")
 */
type: string | null; 
/**
 * Whether the playlist is publicly visible
 */
publicPlaylist: boolean; 
/**
 * Playlist cover image identifier
 * 
 * Use image_url() to get the full URL of the image
 */
image: string | null; 
/**
 * Square version of the playlist cover image
 * 
 * Use square_image_url() to get the full URL of the square image
 */
squareImage: string | null; 
/**
 * Custom image URL for the playlist
 */
customImageUrl: string | null; 
/**
 * Artists promoted in this playlist
 */
promotedArtists: ArtistSummaryDTO[] | null; 
/**
 * ETag for concurrency control when modifying the playlist
 * 
 * This is needed for adding or removing tracks from the playlist
 */
etag: string | null }
export type QueueUpdated = TrackDTO[]
/**
 * Represents a track from the Tidal catalog.
 * 
 * This structure contains all available information about a track,
 * including metadata, audio quality, and associated album/artist data.
 */
export type TrackDTO = { 
/**
 * Unique track identifier
 */
id: string; 
/**
 * Track number within the album
 */
trackNumber: number; 
/**
 * List of artists who contributed to this track
 */
artists?: ArtistSummaryDTO[]; 
/**
 * Album information for this track
 */
album: AlbumSummaryDTO; 
/**
 * Audio quality level available for this album for standard streaming
 * 
 * Higher quality streams may be available than is indicated here when using MPEG-DASH for playback.
 */
audioQuality: AudioQualityDTO; 
/**
 * Duration of the track in seconds
 */
duration: number; 
/**
 * Whether the track contains explicit content
 */
explicit: boolean; 
/**
 * International Standard Recording Code (ISRC)
 */
isrc: string | null; 
/**
 * Popularity score for the track
 */
popularity: number; 
/**
 * Track title
 */
title: string; 
/**
 * Additional media metadata and tags
 */
mediaMetadata: MediaMetadataDTO | null; 
/**
 * Copyright information
 */
copyright: string | null; 
/**
 * Tidal URL for the track
 */
url: string | null; 
/**
 * Beats per minute (BPM) of the track
 */
bpm: number | null; upload: boolean | null }
export type UpdatedCurrentTrack = TrackDTO | null
export type UpdatedPauseState = boolean
export type UpdatedTrackProgress = number

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
